<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="第零章 计算机基础 # 操作系统是连接硬件和用户的，让用户不用对着机器文档编程，更方便 操作系统用来有效率地控制计算机的硬件资源，并且提供方便程序员编程的接口
第一章 Linux是什么 # 网路基础： http://www.study-area.org/network/network.htm
在Linux系统中， 每个设备都被当成一个文件来对待
第二章 主机规划与磁盘分区 # 第三章 安装一个Linux系统s # 简单翻过去了
第四章 首次登陆与线上求助 # man指令学到了很多小技巧，比如/search 一些数字的含义 如果忘记指令了怎么办？ man后面的一些后缀 nano vimtutor
第五章 Linux文件权限与目录配置 # 各种权限查看和更改
ls -l
chgrp, chown, chmod 各种权限是什么含义，尤其是目录文件的 注意目录的x权限 绝对目录、相对目录
第六章 Linux文件与目录管理 # .和..和~
PATH
rmdir 删除空目录 rm-r 删除不空的目录
mv除了移动文件，也可以用作文件的更名
管线|：前一个指令输出的讯息，通过管线交给后续的指令继续使用
eg：cat -n /etc/man_db.conf | head -n 20 | tail -n 10 分号；：在一行中输入多个指令
touch 创建新的空文件，修改 /atime（access读取时间）和mtime（modify修改时间），不能修改ctime（status time）
查阅文件内容 cat, less, more, tail, head">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="Linux1" />
<meta property="og:description" content="第零章 计算机基础 # 操作系统是连接硬件和用户的，让用户不用对着机器文档编程，更方便 操作系统用来有效率地控制计算机的硬件资源，并且提供方便程序员编程的接口
第一章 Linux是什么 # 网路基础： http://www.study-area.org/network/network.htm
在Linux系统中， 每个设备都被当成一个文件来对待
第二章 主机规划与磁盘分区 # 第三章 安装一个Linux系统s # 简单翻过去了
第四章 首次登陆与线上求助 # man指令学到了很多小技巧，比如/search 一些数字的含义 如果忘记指令了怎么办？ man后面的一些后缀 nano vimtutor
第五章 Linux文件权限与目录配置 # 各种权限查看和更改
ls -l
chgrp, chown, chmod 各种权限是什么含义，尤其是目录文件的 注意目录的x权限 绝对目录、相对目录
第六章 Linux文件与目录管理 # .和..和~
PATH
rmdir 删除空目录 rm-r 删除不空的目录
mv除了移动文件，也可以用作文件的更名
管线|：前一个指令输出的讯息，通过管线交给后续的指令继续使用
eg：cat -n /etc/man_db.conf | head -n 20 | tail -n 10 分号；：在一行中输入多个指令
touch 创建新的空文件，修改 /atime（access读取时间）和mtime（modify修改时间），不能修改ctime（status time）
查阅文件内容 cat, less, more, tail, head" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/docs/stage1/linux1/" /><meta property="article:section" content="docs" />

<meta property="article:modified_time" content="2023-02-21T22:37:37+08:00" />
<title>Linux1 | My CS Learning</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.c58292d36b18b675680ab9baea2029204537b839ea72f258746ec0f32ce8d6c8.css" integrity="sha256-xYKS02sYtnVoCrm66iApIEU3uDnqcvJYdG7A8yzo1sg=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.b20483a265e0dbab92fd2aaeb838ed8bcf529e00c837e94437a839e94f88d925.js" integrity="sha256-sgSDomXg26uS/SquuDjti89SngDIN&#43;lEN6g56U&#43;I2SU=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>My CS Learning</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/stage1/ansible/" class="">Ansible</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/stage2/cicd/" class="">CI/CD</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/oatk/database/" class="">Database</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/stage2/docker-in-action/" class="">Docker in Action</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/stage1/git/" class="">Git</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/stage2/go/" class="">Go</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/stage2/k8s-in-action/" class="">K8s in Action</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/stage1/linux1/" class="active">Linux1</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/stage2/linux2/" class="">Linux2</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/stage1/make_file/" class="">Make File</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/oatk/postgresql/" class="">PostgreSQL</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/stage1/tmux/" class="">Tmux</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/others/c/" class="">C</a>
  

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Linux1</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第零章-计算机基础">第零章 计算机基础</a></li>
    <li><a href="#第一章-linux是什么">第一章 Linux是什么</a></li>
    <li><a href="#第二章-主机规划与磁盘分区">第二章 主机规划与磁盘分区</a></li>
    <li><a href="#第三章-安装一个linux系统s">第三章 安装一个Linux系统s</a></li>
    <li><a href="#第四章-首次登陆与线上求助">第四章 首次登陆与线上求助</a></li>
    <li><a href="#第五章-linux文件权限与目录配置">第五章 Linux文件权限与目录配置</a></li>
    <li><a href="#第六章-linux文件与目录管理">第六章 Linux文件与目录管理</a></li>
    <li><a href="#第七章-linux磁盘和文件系统">第七章 Linux磁盘和文件系统</a></li>
    <li><a href="#第八章-压缩打包与备份">第八章 压缩打包与备份</a></li>
    <li><a href="#第九章-vim">第九章 Vim</a></li>
    <li><a href="#第十章-bash">第十章 BASH</a></li>
    <li><a href="#第十一章-正规表示法与文件格式化处理">第十一章 正规表示法与文件格式化处理</a></li>
    <li><a href="#第十二章-shell-scripts">第十二章 Shell Scripts</a></li>
    <li><a href="#第十三章-账号管理与acl权限设定">第十三章 账号管理与ACL权限设定</a></li>
    <li><a href="#第十四章-磁盘配额quota与进阶文件系统管理">第十四章 磁盘配额(Quota)与进阶文件系统管理</a></li>
    <li><a href="#第十六章-进程管理与selinux初探">第十六章 进程管理与SELinux初探</a></li>
    <li><a href="#第十七章-系统服务daemons">第十七章 系统服务daemons</a></li>
    <li><a href="#第十八章-认识与分析登录档">第十八章 认识与分析登录档</a></li>
    <li><a href="#第十九章-开机流程模块管理与loader">第十九章 开机流程、模块管理与Loader</a></li>
    <li><a href="#第二十章-基础系统设定与备份策略">第二十章 基础系统设定与备份策略</a></li>
    <li><a href="#第二十一章-软件安装原始码与tarball">第二十一章 软件安装：原始码与Tarball</a></li>
    <li><a href="#第二十二章-软件安装rpmsrpm与yum">第二十二章 软件安装RPM，SRPM与YUM</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="第零章-计算机基础">
  第零章 计算机基础
  <a class="anchor" href="#%e7%ac%ac%e9%9b%b6%e7%ab%a0-%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%9f%ba%e7%a1%80">#</a>
</h1>
<p>操作系统是连接硬件和用户的，让用户不用对着机器文档编程，更方便
操作系统用来有效率地控制计算机的硬件资源，并且提供方便程序员编程的接口</p>
<h1 id="第一章-linux是什么">
  第一章 Linux是什么
  <a class="anchor" href="#%e7%ac%ac%e4%b8%80%e7%ab%a0-linux%e6%98%af%e4%bb%80%e4%b9%88">#</a>
</h1>
<p>网路基础：
<a href="http://www.study-area.org/network/network.htm">http://www.study-area.org/network/network.htm</a></p>
<p>在Linux系统中， 每个设备都被当成一个文件来对待</p>
<h1 id="第二章-主机规划与磁盘分区">
  第二章 主机规划与磁盘分区
  <a class="anchor" href="#%e7%ac%ac%e4%ba%8c%e7%ab%a0-%e4%b8%bb%e6%9c%ba%e8%a7%84%e5%88%92%e4%b8%8e%e7%a3%81%e7%9b%98%e5%88%86%e5%8c%ba">#</a>
</h1>
<h1 id="第三章-安装一个linux系统s">
  第三章 安装一个Linux系统s
  <a class="anchor" href="#%e7%ac%ac%e4%b8%89%e7%ab%a0-%e5%ae%89%e8%a3%85%e4%b8%80%e4%b8%aalinux%e7%b3%bb%e7%bb%9fs">#</a>
</h1>
<p>简单翻过去了</p>
<h1 id="第四章-首次登陆与线上求助">
  第四章 首次登陆与线上求助
  <a class="anchor" href="#%e7%ac%ac%e5%9b%9b%e7%ab%a0-%e9%a6%96%e6%ac%a1%e7%99%bb%e9%99%86%e4%b8%8e%e7%ba%bf%e4%b8%8a%e6%b1%82%e5%8a%a9">#</a>
</h1>
<p>man指令学到了很多小技巧，比如/search
一些数字的含义
如果忘记指令了怎么办？ man后面的一些后缀
nano
vimtutor</p>
<h1 id="第五章-linux文件权限与目录配置">
  第五章 Linux文件权限与目录配置
  <a class="anchor" href="#%e7%ac%ac%e4%ba%94%e7%ab%a0-linux%e6%96%87%e4%bb%b6%e6%9d%83%e9%99%90%e4%b8%8e%e7%9b%ae%e5%bd%95%e9%85%8d%e7%bd%ae">#</a>
</h1>
<p>各种权限查看和更改</p>
<ul>
<li>
<p>ls -l</p>
</li>
<li>
<p>chgrp, chown, chmod
各种权限是什么含义，尤其是目录文件的
注意目录的x权限
绝对目录、相对目录</p>
</li>
</ul>
<h1 id="第六章-linux文件与目录管理">
  第六章 Linux文件与目录管理
  <a class="anchor" href="#%e7%ac%ac%e5%85%ad%e7%ab%a0-linux%e6%96%87%e4%bb%b6%e4%b8%8e%e7%9b%ae%e5%bd%95%e7%ae%a1%e7%90%86">#</a>
</h1>
<ul>
<li>
<p>.和..和~</p>
</li>
<li>
<p>PATH</p>
</li>
<li>
<p>rmdir 删除空目录 rm-r 删除不空的目录</p>
</li>
<li>
<p>mv除了移动文件，也可以用作文件的更名</p>
</li>
<li>
<p>管线|：前一个指令输出的讯息，通过管线交给后续的指令继续使用</p>
<ul>
<li>eg：cat -n /etc/man_db.conf | head -n 20 | tail -n 10</li>
</ul>
</li>
<li>
<p>分号；：在一行中输入多个指令</p>
</li>
<li>
<p>touch 创建新的空文件，修改 /atime（access读取时间）和mtime（modify修改时间），不能修改ctime（status time）</p>
</li>
<li>
<p>查阅文件内容 cat, less, more, tail, head</p>
</li>
<li>
<p>默认权限 umask</p>
<ul>
<li>文件 666 默认没有x（不可执行）</li>
<li>目录 777 默认有x（可以进入目录）</li>
</ul>
</li>
<li>
<p>特殊权限 SUID、SGID、SBIT</p>
<ul>
<li>4 SUID：使用者执行这一程序时，执行过程中会暂时拥有程序拥有者的权限，例如：passwd修改自己的密码</li>
<li>2 SGID：使用者在这个目录下新建的文件的群组都会和该目录的群组名称相同
<ul>
<li>小组作业，小组内部成员可以同一个目录底下工作，但是小组成员还是拥有自己的家目录和私有群组，那么可以新建小组群组并将小组成员添加到这个群组，新建小组任务文件夹，然后将该文件夹权限设置为2770（13章任务二例题）</li>
</ul>
</li>
<li>1 SBIT：该目录下使用者创建的文件只有自己与root能够删除</li>
</ul>
</li>
<li>
<p>chattr和lsattr设置观察隐藏属性</p>
</li>
<li>
<p>which查指令</p>
</li>
<li>
<p>whereis查文件很快，后面要接文件的完整名字</p>
</li>
<li>
<p>locate查文件也很快，并且后面不需要接完整的名字，但是因为查的是数据库里的数据，所以有时候需要updatedb来更新数据库</p>
<ul>
<li>updatedb执行比较慢</li>
</ul>
</li>
<li>
<p>find 很万能</p>
<ul>
<li>find [PATH] [option]</li>
<li>e.g., find / -name &lsquo;<em>passwd</em>&rsquo;</li>
</ul>
</li>
</ul>
<h1 id="第七章-linux磁盘和文件系统">
  第七章 Linux磁盘和文件系统
  <a class="anchor" href="#%e7%ac%ac%e4%b8%83%e7%ab%a0-linux%e7%a3%81%e7%9b%98%e5%92%8c%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f">#</a>
</h1>
<ul>
<li>ext文件系统: superblock, inode, block
<ul>
<li>journal: 多一个记录区记录系统主要活动，可以加快系统复原时间</li>
</ul>
</li>
<li>xfs文件系统: 格式化快，能处理大文件</li>
<li>hard link和symbolic link
<ul>
<li>hard link 实体链接多了一个文件名对该inode号码的链接</li>
<li>symbolic link 符号链接，类似win的快捷方式</li>
</ul>
</li>
<li>分区gdisk，格式化mkfs，挂载mount</li>
<li>内存置换空间swap</li>
</ul>
<h1 id="第八章-压缩打包与备份">
  第八章 压缩打包与备份
  <a class="anchor" href="#%e7%ac%ac%e5%85%ab%e7%ab%a0-%e5%8e%8b%e7%bc%a9%e6%89%93%e5%8c%85%e4%b8%8e%e5%a4%87%e4%bb%bd">#</a>
</h1>
<ul>
<li>压缩: gzip, bzip2, xz (压缩比越来越高，压缩速度越来越慢)</li>
<li>打包: tar
<ul>
<li>压缩+打包的文件叫做tarball</li>
<li><img src="/../img/image-20230221104200221.png" alt="image-20230221104200221" /></li>
</ul>
</li>
<li>备份：xfsdump, xfsrestore</li>
</ul>
<h1 id="第九章-vim">
  第九章 Vim
  <a class="anchor" href="#%e7%ac%ac%e4%b9%9d%e7%ab%a0-vim">#</a>
</h1>
<ul>
<li>:sp 可以分窗口，ctrl+w+上/下 可以控制不同的窗口</li>
<li>其他的可以现查</li>
<li>暂存档 .swp</li>
</ul>
<h1 id="第十章-bash">
  第十章 BASH
  <a class="anchor" href="#%e7%ac%ac%e5%8d%81%e7%ab%a0-bash">#</a>
</h1>
<ul>
<li>
<p>之前的指令在.bash_history中</p>
</li>
<li>
<p><img src="/../img/image-20230221105647179.png" alt="image-20230221105647179" /></p>
</li>
<li>
<p><code>echo $variable</code></p>
</li>
<li>
<p>定义变量 <code>myname=VBird</code></p>
</li>
<li>
<p>环境变量env, export, 所有变量set</p>
<ul>
<li>export variable, 将自定义变量变成环境变量，分享自己的变量设定给后来的其他程序</li>
</ul>
</li>
<li>
<p>取消变量 unset</p>
</li>
<li>
<p>read -pt variable 读取键盘输入作为变量</p>
</li>
<li>
<p>declear 声明变量的类型</p>
</li>
<li>
<p>shell里面的很多设置和配置文件介绍</p>
</li>
<li>
<p>source 配置文件名，不需要注销再登录，直接将修改后的设定写入配置文件</p>
</li>
<li>
<p>stty [-a] seeting tty的各个按键参数（例如 ctrl c等）</p>
</li>
<li>
<p>bash中的特殊符号与通配符</p>
<ul>
<li>$?表示前一个指令执行完毕后的回传值，为0表示执行成功</li>
<li><img src="/../img/image-20230221110555075.png" alt="image-20230221110555075" /></li>
<li><img src="/../img/image-20230221110635789.png" alt="image-20230221110635789" /></li>
<li>双星号
<ul>
<li>**/*.war: 所有文件夹下的 .war 文件</li>
<li>*.war: 当前文件夹下的 .war 文件</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数据流重导向：指令执行后应该出现在屏幕上的数据给传到其他地方去</p>
<ul>
<li>&gt;, &raquo;, 2&gt;, 2&raquo;
<ul>
<li>example 1: command &gt; doc1 2&gt; doc2
<ul>
<li>stdout存到doc1</li>
<li>stderr存到doc2</li>
</ul>
</li>
<li>example 2: command 2&gt; /dev/null
<ul>
<li>黑洞装置/dev/null，将错误信息吃掉，既不显示在屏幕上又不储存</li>
</ul>
</li>
<li>example 3: command &gt; doc 2&gt;&amp;1
<ul>
<li>将stdout和stderr写入同一个文件
同理也有 1&gt;&amp;2</li>
</ul>
</li>
</ul>
</li>
<li>&lt;, &laquo;
<ul>
<li>&lt; 用文件内容取代键盘输入</li>
<li>&laquo; 后接结束的输入字符</li>
</ul>
</li>
<li>tee：同时输出给文件和屏幕
<ul>
<li>e.g.: python run.py 2&gt;&amp;1 | tee train.log</li>
</ul>
</li>
</ul>
</li>
<li>
<p>多条命令一次输入来执行</p>
<ul>
<li>cmd1; cmd2
<ul>
<li>指令之间没有相关性。</li>
</ul>
</li>
<li>cmd1 &amp;&amp; 或 || cmd2
<ul>
<li>前一个指令是否成功执行与后一个指令是否要执行相关</li>
<li>假设判断式：cmd1 &amp;&amp; cmd2 || cmd3</li>
</ul>
</li>
</ul>
</li>
<li>
<p>管线pipe</p>
<ul>
<li>
<p>与连续下达命令的区别？</p>
</li>
<li>
<p>| ：只能处理前一个指令传来的正确信息, i.e., stdout, 不能处理错误信息</p>
<ul>
<li>
<p><img src="/../img/image-20230221115142361.png" alt="image-20230221115142361" /></p>
</li>
<li>
<p>能够接受std input的命令才是管线命令</p>
<ul>
<li>less, more, cat等可以</li>
<li>ls, cp, mv 等这些不行</li>
</ul>
</li>
<li>
<p>硬要处理错误信息的话，就用数据流重导向2&gt;&amp;1</p>
</li>
</ul>
</li>
<li>
<p>撷(xie 2)取命令</p>
<ul>
<li>行 为单位</li>
<li>cut
<ul>
<li>处理特定分割的数据，例如echo ${PATH}中有&quot;：&quot;</li>
<li>处理排列整齐的数据，例如export</li>
<li>处理多空格相连的数据比较费劲</li>
</ul>
</li>
<li>grep
<ul>
<li>取出有特定信息‘text’的那一行</li>
</ul>
</li>
</ul>
</li>
<li>
<p>排序命令 sort</p>
</li>
<li>
<p>重复的信息只显示一个 uniq，配合排序过的文件来处理，先sort再uniq</p>
</li>
<li>
<p>输出数据各种计数 wc：行、字数、字符数</p>
</li>
<li>
<p>同时将数据流输出给文件和屏幕：tee</p>
</li>
<li>
<p>tr 删除或者替换文字</p>
</li>
<li>
<p>col 将tab键转换成对等的空格键</p>
<ul>
<li>和expand什么区别？</li>
</ul>
</li>
<li>
<p>join 将两个文件中有 相同数据 的那一行加在一起</p>
<ul>
<li>join之前，先排序</li>
</ul>
</li>
<li>
<p>paste 将文件两行贴在一起，用tab来分隔</p>
<ul>
<li>file如果写成-，代表资料来自standard input</li>
</ul>
</li>
<li>
<p>expand将tab转成空格键</p>
<ul>
<li>和col什么区别？</li>
</ul>
</li>
<li>
<p>分区命令 split 将大文件分成小文件</p>
<ul>
<li>分区之后合并，用数据流重导向&raquo;就可以了</li>
</ul>
</li>
<li>
<p>参数代换 xargs：产生某个指令的参数</p>
<ul>
<li>xargs可以读入stdin的数据，并且以空白或者断行字符作为分辨，将stdin的数据分隔成arguments</li>
<li>xargs [-0epn] command
<ul>
<li>-n 后面接次数，每次command执行需要几个参数的意思</li>
</ul>
</li>
<li>主要用法：很多指令不是管线命令，用xargs来引导这些指令使用std input
<ul>
<li>id command的例子</li>
</ul>
</li>
<li>另一个用法：数据量很大，使用xargs每次丢几个给command处理（11章第一个例题）</li>
</ul>
</li>
<li>
<p>“-” 前一个指令的stdout作为这次的stdin，那么stdout和stdin可以用“-”来替代</p>
</li>
</ul>
</li>
<li>
<p>一个区分：type 指令是何种类型，file 是文件是什么类型</p>
</li>
</ul>
<h1 id="第十一章-正规表示法与文件格式化处理">
  第十一章 正规表示法与文件格式化处理
  <a class="anchor" href="#%e7%ac%ac%e5%8d%81%e4%b8%80%e7%ab%a0-%e6%ad%a3%e8%a7%84%e8%a1%a8%e7%a4%ba%e6%b3%95%e4%b8%8e%e6%96%87%e4%bb%b6%e6%a0%bc%e5%bc%8f%e5%8c%96%e5%a4%84%e7%90%86">#</a>
</h1>
<ul>
<li>
<p>正规表示法，regular expression, 正则表达式</p>
</li>
<li>
<p>搜索、删除、取代特定的字符串，以行为单位</p>
</li>
<li>
<p>有些工具支持正规表示法，比如grep，有些不支持，比如cp, ls，它们只能使用bash自己本身的通配符</p>
</li>
<li>
<p>与通配符有什么区别？</p>
<ul>
<li>通配符(wildcard)是bash操作环境里的东西，是bash的一个功能</li>
<li>正则表示法是字符串处理的一种表示方式</li>
</ul>
</li>
<li>
<p>基础正规表示法</p>
<ul>
<li>搜索特定字符串 grep &rsquo;text&rsquo; file</li>
<li>利用中括号[]搜索集合字符
<ul>
<li>e.g., &rsquo;t[ae]st&rsquo;, []里面代表一个字符，这个字符是a或者e</li>
<li>e.g., &lsquo;[^a-z]oo&rsquo;, oo前面不能是小写字母</li>
<li>e.g., &lsquo;[^[:lower:]]oo&rsquo;, oo前面不能是小写字母</li>
</ul>
</li>
<li>行首^，行尾$
<ul>
<li>e.g., &lsquo;^the&rsquo;, 以the开头</li>
<li>e.g., &lsquo;^[a-z]&rsquo; 或者 &lsquo;^[[:lower:]]&rsquo;, 以小写字母开头</li>
<li>&ldquo;^&ldquo;符号在字符集合符号[]内外的含义不同，在[]内表示反向选择，在[]外表示行首</li>
<li>e.g., <code>\.$</code>结尾的行，注意使用跳脱字符\</li>
<li>空白行<code>^$</code></li>
</ul>
</li>
<li>&ldquo;.&ldquo;一定有一个任意字符，&rdquo;*&ldquo;重复前一个字符0到无数次
<ul>
<li>&lsquo;o*&lsquo;指的是空字符或者一个及以上o, &lsquo;oo*&rsquo; 指的是有一个以上o</li>
<li>&lsquo;.*&rsquo; 指零个或多个任意字符</li>
</ul>
</li>
<li>{} 限定字符范围
<ul>
<li>e.g.,</li>
<li>e.g., &lsquo;go\{2,5\}g&rsquo;, g后面接2到5个o，再接一个g
<ul>
<li>注意使用跳脱字符\</li>
</ul>
</li>
<li>e.g., &lsquo;go\{2,\}g&rsquo;, 接2个以上o</li>
</ul>
</li>
<li>sed工具
<ul>
<li>是个管线命令，用来分析standard input</li>
<li>后面接的动作，要用单引号&rsquo; &lsquo;括住
<ul>
<li>如果接超过两个以上的动作，那么每个动作前要加上 -e</li>
</ul>
</li>
<li>功能
<ul>
<li>新增、插入、删除</li>
<li>（整行）取代、显示</li>
<li>部分数据的搜寻取代 sed &rsquo;s/要被取代的字符串/新的字符串/g&rsquo;</li>
<li>-i 直接修改文件内容，要小心</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>延伸正规表示法</p>
<ul>
<li>egrep</li>
<li>&ldquo;+&rdquo; 一个或一个以上前一个字符：o+表示一个以上的o</li>
<li>&ldquo;?&ldquo;零个或一个前一个字符：o? 表示空或者一个o</li>
<li>&ldquo;|&rdquo; 或，&lsquo;gd|good&rsquo;, gd或good</li>
<li>&ldquo;()&rdquo; 找出群组字符串
<ul>
<li>搜寻glad或good：g(la|oo)d</li>
</ul>
</li>
<li>&ldquo;()+&rdquo; 重复群组</li>
</ul>
</li>
<li>
<p>格式化打印 printf</p>
<ul>
<li>printf &lsquo;打印格式&rsquo; 实际内容</li>
<li>不是管线命令 <code>printf '%s\t %s\t %s\t \n' $(cat printf.txt)</code></li>
<li>%8.2f, 五位整数，两位小数，一位小数点，总共八位</li>
</ul>
</li>
<li>
<p>数据处理工具awk</p>
<ul>
<li>是个管线命令，可以处理std input或者文件</li>
<li><code>$1$</code>,<code> $2$</code> &hellip; 代表第x个字段
<ul>
<li>字段间以空格或者tab键隔开</li>
<li><code>$0$</code> 代表一整行</li>
</ul>
</li>
<li>每次处理一行，字段是最小处理单位</li>
<li>BEGIN 关键词 预先设定awk的变量</li>
<li>awk里面的&rsquo;&lsquo;变成“”</li>
</ul>
</li>
<li>
<p>文件对比</p>
<ul>
<li>diff
<ul>
<li>是管线命令</li>
<li>以行为单位对比</li>
<li>除了对比文件，也可以对比目录</li>
</ul>
</li>
<li>cmp
<ul>
<li>也是管线命令</li>
<li>只能对比文件</li>
<li>以字节为单位对比</li>
</ul>
</li>
<li>patch
<ul>
<li>补丁档，将旧的文档升级到新的文档</li>
<li>比较新旧版本的差异，将差异档制作成为补丁档，用补丁档更新旧文件</li>
</ul>
</li>
</ul>
</li>
<li>
<p>文件打印 pr</p>
</li>
<li>
<p>文件时间，文件档名，页码</p>
<h1 id="第十二章-shell-scripts">
  第十二章 Shell Scripts
  <a class="anchor" href="#%e7%ac%ac%e5%8d%81%e4%ba%8c%e7%ab%a0-shell-scripts">#</a>
</h1>
</li>
<li>
<p>如何执行一个shell scripts文件（首先要有rx权限）</p>
<ul>
<li>/绝对路径/shell.sh</li>
<li>相对路径，./shell.sh</li>
<li>将shell.sh放在PATH目录里，然后可以直接 shell.sh</li>
<li>bash shell.sh （只要有r权限就可以）</li>
<li>source shell.sh 【在父程序bash执行】</li>
</ul>
</li>
<li>
<p>写一个shell script程序</p>
<ul>
<li>
<p>第一行 #!/bin/bash</p>
</li>
<li>
<p>注释说明</p>
<ul>
<li>script的功能，版本信息，较特殊的需要使用绝对路径的方式来下达的指令，需要的环境变量宣告与设定</li>
</ul>
</li>
<li>
<p>宣告环境变量</p>
</li>
<li>
<p>主要程序</p>
</li>
<li>
<p>执行结果告知（回传值）</p>
</li>
</ul>
</li>
<li>
<p>数值计算 <code>var=\$((运算内容))</code></p>
</li>
<li>
<p>判断式</p>
<ul>
<li>test指令
<ul>
<li>判断文件是否存在，什么类型权限，文件比较，字符串数据等</li>
<li>反状态，test ! -x file</li>
</ul>
</li>
<li>判断符号 <input disabled="" type="checkbox"> 
<ul>
<li>每个组件之间都需要空格来分隔</li>
<li>变量需要用双引号括号起来</li>
<li>常量需要用单或双引号括号起来</li>
<li>e.g., <code>[ [] &quot;$HOME&quot;[]==[]&quot;$MAIL&quot;[] ]</code></li>
<li>经常用在条件判断式中 if&hellip;then&hellip;fi</li>
</ul>
</li>
<li>默认变量
<ul>
<li>可以通过 script.sh variable 来直接给变量，也可以通过read交互式</li>
<li>$0: 文件名</li>
<li><code>$1, $2, $3 ...</code> 第一、二、三&hellip;个参数</li>
<li><code>$#</code>: 参数数目
<code>$@</code>: 全部的参数内容，i.e.,<code>&quot;$1&quot; &quot;$2&quot; &quot;$3&quot; &quot;$4&quot;......</code></li>
<li>变量偏移shift number，拿掉最前面的几个参数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>条件判断式</p>
<ul>
<li>
<p>单层、简单的</p>
<pre tabindex="0"><code>if [条件判断式]; then
    ...
fi
</code></pre><ul>
<li>[] || [] 或者 &amp;&amp;</li>
</ul>
</li>
<li>
<p>多层的</p>
<ul>
<li>if [条件判断式]; then &hellip; else &hellip; fi</li>
<li>if [条件判断式一]; then &hellip; elif [条件判断式二]; then &hellip; else &hellip; fi</li>
</ul>
</li>
<li>
<p>case</p>
<ul>
<li><img src="/../img/image-20230221203003800.png" alt="image-20230221203003800" /></li>
</ul>
</li>
</ul>
</li>
<li>
<p>function功能</p>
<ul>
<li><img src="/../img/image-20230221203051087.png" alt="image-20230221203051087" /></li>
<li>要放在程序最前面</li>
<li>也有默认变量 <code>$0, $1, $2.....</code>
<ul>
<li><code>$0</code>指的是function函数名称</li>
<li><code>$1, $2 ...</code>都和script的不一样，是函数的</li>
</ul>
</li>
</ul>
</li>
<li>
<p>循环 loop</p>
<ul>
<li>
<p>不定循环</p>
<ul>
<li><img src="/../img/image-20230221203645822.png" alt="image-20230221203645822" /></li>
<li><img src="/../img/image-20230221203715297.png" alt="image-20230221203715297" /></li>
</ul>
</li>
<li>
<p>固定循环</p>
<ul>
<li><img src="/../img/image-20230221203845941.png" alt="image-20230221203845941" />
<ul>
<li>var的值分别是con1，con2，con3</li>
</ul>
</li>
<li><code>$(seq ...)</code>
<ul>
<li>e.g.: $(seq 1 100)</li>
<li>也可以用 {1..100}</li>
</ul>
</li>
<li><img src="/../img/image-20230221204018580.png" alt="image-20230221204018580" />
<ul>
<li>可以用 i++</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>shell script 追踪与debug</p>
<ul>
<li>bash [-nvx] scripts.sh</li>
<li>书上的command用的是sh，但是其实是bash，我没有设置sh是bash的alias，如果用sh的话，for数值循环会报错</li>
</ul>
</li>
</ul>
<h1 id="第十三章-账号管理与acl权限设定">
  第十三章 账号管理与ACL权限设定
  <a class="anchor" href="#%e7%ac%ac%e5%8d%81%e4%b8%89%e7%ab%a0-%e8%b4%a6%e5%8f%b7%e7%ae%a1%e7%90%86%e4%b8%8eacl%e6%9d%83%e9%99%90%e8%ae%be%e5%ae%9a">#</a>
</h1>
<ul>
<li>账号与群组
<ul>
<li>/etc/passwd 文件</li>
<li>/etc/shadow 文件</li>
<li>/etc/group 文件
<ul>
<li>群组、有效群组（command groups 出来的第一个群组，作用在新建文件）、初始群组（passwd中的第四栏）</li>
<li>newgrp来切换有效群组，是以另一个shell来提供这个功能的，所以结束后要exit
<ul>
<li><img src="/../img/image-20230221204357899.png" alt="image-20230221204357899" /></li>
</ul>
</li>
</ul>
</li>
<li>/etc/gshadow 文件，用来设置群组管理员</li>
</ul>
</li>
<li>账号管理
<ul>
<li>useradd建立账号
<ul>
<li>-s /sbin/nologin 使得用户无法登入系统取得shell</li>
</ul>
</li>
<li>/etc/skel 用户家目录的参考基准目录，家目录中的默认数据是由这个目录复制过去的</li>
<li>/etc/login.defs  UID/GID/密码参数等</li>
<li>passwd 修改（设置）密码</li>
<li>chage 详细的密码参数</li>
<li>usermod 微调useradd的参数
<ul>
<li>root通过usermod -a user1 -G group1 将user1新加到group1</li>
</ul>
</li>
<li>userdel 删除用户数据</li>
<li>finger, chfn, chsh</li>
<li>groupadd, groupmod, groupdel
<ul>
<li>要删除群组，要确认没有账号使用该群组作为初始群组，否则无法删除</li>
</ul>
</li>
<li>群组管理员 gpasswd</li>
<li>小组作业，小组内部成员可以同一个目录底下工作，但是小组成员还是拥有自己的家目录和私有群组，那么可以新建小组群组并将小组成员添加到这个群组，新建小组任务文件夹，然后将该文件夹权限设置为2770（13章任务二例题）</li>
<li>外部身份验证系统 authconfig-tui: CentOS的，Ubuntu没有这个指令</li>
</ul>
</li>
<li>主机的细部权限规划: ACL的使用
<ul>
<li>Access Control List，为单一的用户或群组设定权限</li>
<li>设定ACL权限 setfacl，查找ACL权限 getfacl
<ul>
<li>setfacl -R 与  setfacl -m d&hellip;.的区别：前者是递归设定之前已经存在的文件的ACL权限，后者是未来文件的ACL权限</li>
<li>要设定一个用户/群组没有任何ACL权限，权限的地方不能直接留白，要加上一个“-”减号</li>
</ul>
</li>
</ul>
</li>
<li>使用者身份切换
<ul>
<li>su
<ul>
<li>&ldquo;-&rdquo;:  使用login shell的方式切换身份，完整切换</li>
<li>&quot; &ldquo;：使用non-login shell的方式</li>
</ul>
</li>
<li>sudo
<ul>
<li>能否执行sudo要看/etc/sudoers
<ul>
<li>使用visudo来修改/etc/sudoers，不能直接vi /etc/sudoers</li>
</ul>
</li>
<li>后接用户自己的密码来确认执行后续的指令</li>
<li>可以设置 sudo su -</li>
</ul>
</li>
</ul>
</li>
<li>用户的特殊shell与PAM模块
<ul>
<li>PAM这块书上是以CentOS为例的，我在ubuntu上没有找到文件在哪里啊
<ul>
<li>找到了，/usr/lib/x86_64-linux-gnu/security/</li>
</ul>
</li>
</ul>
</li>
<li>用户信息传递
<ul>
<li>查询使用者：w, who, lastlog</li>
<li>使用者对谈：write
<ul>
<li>拒绝接收信息 mesg n，但无法拒绝来自root的信息</li>
</ul>
</li>
<li>对所有系统上在线的用户广播：wall</li>
<li>邮件：mail</li>
</ul>
</li>
<li>账号检查工具
<ul>
<li>Ubuntu 的passwd指令没有–stdin
<ul>
<li>可以用chpasswd</li>
</ul>
</li>
<li>一个大量新建设置账号的脚本模板</li>
</ul>
</li>
</ul>
<h1 id="第十四章-磁盘配额quota与进阶文件系统管理">
  第十四章 磁盘配额(Quota)与进阶文件系统管理
  <a class="anchor" href="#%e7%ac%ac%e5%8d%81%e5%9b%9b%e7%ab%a0-%e7%a3%81%e7%9b%98%e9%85%8d%e9%a2%9dquota%e4%b8%8e%e8%bf%9b%e9%98%b6%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%ae%a1%e7%90%86">#</a>
</h1>
<ul>
<li>
<p>什么是Quota? 让磁盘容量公平的分配</p>
<ul>
<li>我的文件系统是ext4，并且/home不是独立的文件系统（mounted on 根目录），所以先跳过了14.1这一节</li>
</ul>
</li>
<li>
<p>磁盘阵列RAID: 将多个较小的磁盘整合成为一个较大的磁盘装置</p>
<ul>
<li>
<p>RAID选择的不同level</p>
<ul>
<li>
<p>RAID-0：等量模式 stripe。只要有任何一颗磁盘损毁，在RAID上面的所有数据都会遗失无法读取</p>
</li>
<li>
<p>RAID-1：映像模式 mirror。同一份数据完整保存在两颗磁盘上。</p>
</li>
<li>
<p>RAID 1+0：最推荐</p>
<ul>
<li><img src="/../img/image-20230221205449948.png" alt="image-20230221205449948" /></li>
</ul>
</li>
<li>
<p>RAID-5：有同位检查码，可以支持一颗磁盘损毁的情况</p>
<ul>
<li><img src="/../img/image-20230221205531404.png" alt="image-20230221205531404" /></li>
<li>同为检查数据（奇偶校验位）是什么？Parity占的存储空间不会是A0+B0的总和吗？
<ul>
<li>我理解的奇偶校验只能知道传输有没有错误，不能用来恢复啊。好像也可以？</li>
</ul>
</li>
<li>为什么是round robin写入的？</li>
<li>另有RAID-6，允许同时两颗磁盘损毁的情况</li>
</ul>
</li>
</ul>
</li>
<li>
<p>预备磁盘 spare disk</p>
<ul>
<li>不支持热插拔的话关机才能动手插拔硬盘</li>
</ul>
</li>
<li>
<p>一些优点</p>
<ul>
<li>数据安全和可靠性：硬件损毁的话能不能安全恢复</li>
<li>读写：RAID 0可以改善系统I/O</li>
<li>扩大容量</li>
</ul>
</li>
<li>
<p>因为硬件磁盘阵列很贵，所有利用软件来仿真磁盘阵列的功能 → 软件磁盘阵列</p>
<ul>
<li>第七章的练习没怎么做
<ul>
<li>我遇到的问题 gdisk /dev/sda</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>逻辑滚动条管理员</p>
<ul>
<li>实现一个可以弹性调整容量的文件系统</li>
</ul>
</li>
</ul>
<p>第十五章 例行性工作排程（crontab）</p>
<ul>
<li>什么是？ 将Linux的例行性工作安排执行的流程
<ul>
<li>分类
<ul>
<li>at：仅执行一次，突发性的</li>
<li>crontab：例行性的，每隔一定周期就要办的事情</li>
</ul>
</li>
<li>一些例行性工作</li>
</ul>
</li>
<li>仅执行一次的工作排程
<ul>
<li>确保atd启动</li>
<li>/etc/at.deny</li>
<li>at指令
<ul>
<li>背景执行功能</li>
</ul>
</li>
<li>atq查询，atrm删除指令</li>
<li>batch指令
<ul>
<li>在CPU的工作负载小于0.8时，再进行工作任务</li>
</ul>
</li>
</ul>
</li>
<li>循环执行的例行性工作排程
<ul>
<li>默认启动</li>
<li>crontab指令</li>
<li>一些注意事项
<ul>
<li>资源分配不均</li>
<li>周和日月不可同时共存</li>
</ul>
</li>
<li>可唤醒停机期间的工作任务
<ul>
<li>anacron 主动帮忙执行时间到了但是却没有执行的排程</li>
<li>时间戳</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第十六章-进程管理与selinux初探">
  第十六章 进程管理与SELinux初探
  <a class="anchor" href="#%e7%ac%ac%e5%8d%81%e5%85%ad%e7%ab%a0-%e8%bf%9b%e7%a8%8b%e7%ae%a1%e7%90%86%e4%b8%8eselinux%e5%88%9d%e6%8e%a2">#</a>
</h1>
<ul>
<li>什么是进程？
<ul>
<li>进程是一个正在运作中的程序</li>
<li>进程呼叫 fork and exec</li>
<li>服务deamon：常驻在内存中的进程，文件名以d结尾</li>
</ul>
</li>
<li>工作管理 job control
<ul>
<li>工作管理是当我们登入系统取得bash shell之后，在单一终端机接口下同时进行多个工作的行为管理</li>
<li>管理的工作都是当前bash的子进程</li>
<li>前景foreground，背景background
<ul>
<li>vim不可能在背景中running</li>
</ul>
</li>
<li>job control的管理
<ul>
<li>直接将指令丢到背景中执行：command+ &amp;，最好使用数据流重导向</li>
<li>将目前的工作丢到背景中，并暂停：ctrl + z</li>
<li>观察目前的背景工作状态：jobs</li>
<li>将背景工作拿到前景来处理：fg
<ul>
<li>%+数字</li>
</ul>
</li>
<li>让工作在背景下的状态从暂停变成运行中：bg</li>
<li>移除工作：kill</li>
</ul>
</li>
<li>脱机管理
<ul>
<li>要注意工作管理的背景仍然和终端机有关，脱机注销之后工作不会继续进行，会中断</li>
<li>工作需要一大段时间，要如何处理
<ul>
<li>使用at</li>
<li>tmux</li>
<li>nohup</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程管理
<ul>
<li>进程的观察
<ul>
<li>ps：某个时间点的进程运作情况
<ul>
<li>僵尸进程 defunct</li>
<li>ps aux 所有进程</li>
<li>ps -l 自己的bash相关进程</li>
</ul>
</li>
<li>top：动态观察进程的变化</li>
<li>pstree：更直观地看进程相关性</li>
</ul>
</li>
<li>进程的管理
<ul>
<li>信息传递 signal
<ul>
<li>常用编号
<ul>
<li>1：重新启动</li>
<li>9：强制中断</li>
<li>15：正常中止</li>
</ul>
</li>
<li>kill -signal PID/%jobnumber</li>
<li>killall -signal 指令名称
<ul>
<li>不需要配合ps来找到进程的ID，而是直接用名称</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程的执行顺序 (priority)
<ul>
<li>CPU排程：每支进程被CPU运行的演算规则</li>
<li>优先执行序 priority，PRI：越低越优先
<ul>
<li>核心动态调整的，用户无法直接调整PRI值</li>
<li>优先级高的程序每秒被运作的次数更多</li>
</ul>
</li>
<li>用户可以条件的是NI值，i.e., nice值
<ul>
<li>条件范围-20~19，一般使用者无法调到负值</li>
<li>指令：nice，renice</li>
<li>修改nice值可以在父进程子进程之间传递</li>
</ul>
</li>
<li>系统资源的观察
<ul>
<li>free 内存使用情况</li>
<li>uname 查询系统与核心相关信息</li>
<li>uptime 系统启动时间与工作负载</li>
<li>netstat 追踪网络或插槽文件</li>
<li>dmesg 分析核心产生的讯息</li>
<li>vmstat 侦测系统资源变化，看看哪个部分的资源被使用的最频繁</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>特殊文件与进程
<ul>
<li>有SUID和SGID权限的指令执行状态
<ul>
<li>程序与进程的区别：SUID程序在运行过程中产生的进程</li>
</ul>
</li>
<li>/proc 里面的文件
<ul>
<li>查询已开启文件或者已执行进程开启的文件
<ul>
<li>fuser：某个文件（或文件系统）目前正被哪些进程所利用</li>
<li>lsof：某个进程开启或者使用的文件与装置</li>
<li>pidof：某支正在被执行的程序的PID
<ul>
<li>另外也可以用 ps aux 配合 grep + 正则表达式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>SELinux
<ul>
<li>Security Enhanced Linux，安全强化的linux</li>
<li>传统的文件权限与账号关系，i.e.，自主式访问控制DAC比较危险，所有使用依据政策规则制定特定进程读取特定文件的委托式访问控制MAC</li>
<li>运作模式
<ul>
<li>主体：进程；目标：文件资源</li>
<li><img src="/../img/image-20230221210528803.png" alt="image-20230221210528803" /></li>
<li>安全性本文可以想成SELinux内必备的rwx</li>
<li>SELinux的重要属性：Type（文件资源）/domain（进程)</li>
</ul>
</li>
<li>三种模式：
<ul>
<li>强制、宽容、关闭</li>
<li>要切换模式的话得重新启动</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第十七章-系统服务daemons">
  第十七章 系统服务daemons
  <a class="anchor" href="#%e7%ac%ac%e5%8d%81%e4%b8%83%e7%ab%a0-%e7%b3%bb%e7%bb%9f%e6%9c%8d%e5%8a%a1daemons">#</a>
</h1>
<ul>
<li>deamons和服务是什么？
<ul>
<li>达成某个服务的程序叫做daemon</li>
<li>systemd启动服务机制</li>
<li>一些概念：
<ul>
<li>服务单位unit，服务类型type：每种服务单位按照功能来划分，可以分成不同的服务类型</li>
<li>操作环境target是服务类型的一种，是一群unit的集合</li>
</ul>
</li>
<li>主要服务类型</li>
<li>systemd启动过程中，无法与管理员透过standard input传入信息</li>
</ul>
</li>
<li>systemctl管理服务
<ul>
<li>单一服务的 systemctl [command] [unit]</li>
<li>如果用kill来关闭一个正常的服务，那么systemctl就无法继续监控这个服务了</li>
<li>deamon的各种状态：active，enabled等</li>
<li>注意service部分用start/stop/restart，target项目用isolate</li>
<li>systemctl list-dependencies</li>
<li>网络服务与对应端口</li>
</ul>
</li>
<li>systemctl针对service类型的配置文件
<ul>
<li>配置文件相关目录</li>
<li>配置文件的设定项目
<ul>
<li>配置文件整体分为三个部分：Unit, Service, Install</li>
<li>每个部分下面有很多参数</li>
</ul>
</li>
<li>简化多个执行的启动设定
<ul>
<li><img src="/../img/image-20230221210832375.png" alt="image-20230221210832375" /></li>
<li>将执行文件中的@范例名称带入到源文件中的%I</li>
</ul>
</li>
</ul>
</li>
<li>systemctl针对timer的配置文件
<ul>
<li>和crond类似，定期执行任务</li>
<li>在ubuntu上叫timers.target</li>
</ul>
</li>
</ul>
<h1 id="第十八章-认识与分析登录档">
  第十八章 认识与分析登录档
  <a class="anchor" href="#%e7%ac%ac%e5%8d%81%e5%85%ab%e7%ab%a0-%e8%ae%a4%e8%af%86%e4%b8%8e%e5%88%86%e6%9e%90%e7%99%bb%e5%bd%95%e6%a1%a3">#</a>
</h1>
<ul>
<li>
<p>登录档是什么：记录系统在什么时候由哪个程序做了什么样的行为，发生了何种的事件</p>
<ul>
<li>一般只有root有权限读取</li>
<li>常见的登录档
<ul>
<li>/var/log/syslog</li>
</ul>
</li>
</ul>
</li>
<li>
<p>rsyslog.service</p>
<ul>
<li>
<p>stand alone deamon</p>
</li>
<li>
<p>配置文件 /etc/rsyslog.conf</p>
<ul>
<li>
<p>语法在这里 /etc/rsyslog.d/50-default.conf</p>
</li>
<li>
<p>服务名称、讯息等级、被记录在哪里</p>
<ul>
<li>服务名称与讯息等级之间的连接符号【.】表示&gt;=后面严重程度的都记录下来</li>
<li>不需要登录等级 .none</li>
</ul>
</li>
<li>
<p>文件名前的“-”：先将讯息存储在速度较快的内存中，等数据量够大了再一次性填入磁盘内</p>
<ul>
<li>编辑登录档后restart rsyslog.service</li>
</ul>
</li>
<li>
<p>可以添加chattr属性来保护登录档，防止手误更改了文件</p>
</li>
</ul>
</li>
<li>
<p>一些区分</p>
<ul>
<li><img src="/../img/image-20230221211443403.png" alt="image-20230221211443403" /></li>
<li>登录档服务器</li>
</ul>
</li>
</ul>
</li>
<li>
<p>登录档的轮替（logrotate）</p>
<ul>
<li>
<p>logrotate是挂在cron底下进行的</p>
</li>
<li>
<p>主要功能</p>
<ul>
<li>将旧的登录档改名字移动成旧档，然后新建新的登录档，旧的登录档一段时间后删除</li>
</ul>
</li>
<li>
<p>配置文件</p>
<ul>
<li>/etc/logrotate.conf</li>
<li>/etc/logrotate.d</li>
<li>基本语法
<ul>
<li>档名，得是绝对路径</li>
<li>参数，monthly等等</li>
<li>执行脚本，需要sharedscripts, prerotate, postrotate, endscript</li>
</ul>
</li>
<li>加了chattr的a属性后不能，文件不能直接更名成功，需要在配置文件里先把a参数去掉，然后再更名，然后再加上这个属性</li>
</ul>
</li>
</ul>
</li>
<li>
<p>systemd-journald.service</p>
<ul>
<li>systemd-journald.service用来管理与查询这次开机后的登录信息，而rsyslogd用来记录以前及现在的数据到磁盘中，方便未来查询</li>
<li>journalctl指令：查询systemd-journald.service的数据</li>
<li>logger指令：将我的数据存储到登录文件中</li>
</ul>
</li>
<li>
<p>分析登录档</p>
<ul>
<li>logwatch</li>
</ul>
</li>
</ul>
<h1 id="第十九章-开机流程模块管理与loader">
  第十九章 开机流程、模块管理与Loader
  <a class="anchor" href="#%e7%ac%ac%e5%8d%81%e4%b9%9d%e7%ab%a0-%e5%bc%80%e6%9c%ba%e6%b5%81%e7%a8%8b%e6%a8%a1%e5%9d%97%e7%ae%a1%e7%90%86%e4%b8%8eloader">#</a>
</h1>
<ul>
<li>
<p>Linux开机流程分析</p>
<ul>
<li>
<p><img src="/../img/image-20230221211734875.png" alt="image-20230221211734875" /></p>
</li>
<li>
<p>第一支程序systemd</p>
<ul>
<li>
<p>PID号码是1号</p>
</li>
<li>
<p>准备软件执行的环境，包括主机名、网络设定等服务的启动</p>
</li>
<li>
<p>操作环境target</p>
</li>
<li>
<p>通过systemctl list-dependencies graphical.target 来观察systemd的大致开机流程</p>
<ul>
<li>
<p><img src="/../img/image-20230221211835667.png" alt="image-20230221211835667" /></p>
</li>
<li>
<p>脚本放在/etc/rc.d/rc.local文件里，可以开机执行</p>
</li>
</ul>
</li>
<li>
<p>用到的主要配置文件</p>
<ul>
<li>加载额外的核心参数设定/etc/modules-load.d/<em>.conf、/etc/modprobe.d/</em>.conf</li>
<li>常见的环境配置文件 /etc/sysconfig/*</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>核心与核心模块</p>
<ul>
<li>核心（kernel），目前都具有可读取模块化驱动程序的功能，也就是modules模块化，可以把它想象成插件</li>
<li>核心相依性 modules.dep</li>
<li>显示所有模块 lsmod</li>
<li>模块信息 modinfo</li>
<li>加载模块 modprobe，会自动检查相依性</li>
</ul>
</li>
<li>
<p>Boot Loader：Grub</p>
<ul>
<li>略过这一节了</li>
</ul>
</li>
<li>
<p>开机过程的问题解决</p>
<ul>
<li>忘记root密码</li>
<li>开机以root执行bash</li>
<li>文件系统错误</li>
</ul>
</li>
</ul>
<h1 id="第二十章-基础系统设定与备份策略">
  第二十章 基础系统设定与备份策略
  <a class="anchor" href="#%e7%ac%ac%e4%ba%8c%e5%8d%81%e7%ab%a0-%e5%9f%ba%e7%a1%80%e7%b3%bb%e7%bb%9f%e8%ae%be%e5%ae%9a%e4%b8%8e%e5%a4%87%e4%bb%bd%e7%ad%96%e7%95%a5">#</a>
</h1>
<ul>
<li>系统基本设定
<ul>
<li>网络设定
<ul>
<li>nmcli指令来手动设定</li>
<li>DHCP自动分配</li>
<li>hostnamectl 主机名</li>
</ul>
</li>
<li>日期和时间设定
<ul>
<li>timedatectl 显示时区时间</li>
</ul>
</li>
<li>语系设定</li>
<li>防火墙简易设定</li>
</ul>
</li>
<li>服务器硬件数据收集
<ul>
<li>dmidecode解析硬件配备</li>
<li>观察硬件状态信息的指令：gdisk, dmesg, vmstat, lspci, lsusb, iostat</li>
<li>了解磁盘的健康状态 smartd
<ul>
<li>虚拟机不支持</li>
</ul>
</li>
</ul>
</li>
<li>备份
<ul>
<li>要备份哪些数据
<ul>
<li>/etc</li>
<li>/home</li>
<li>/root</li>
<li>/var/spool/mail/, /var/spool/cron/, /var/spool/at/</li>
<li>/var/lib/</li>
</ul>
</li>
<li>备份的种类
<ul>
<li>完整数据备份
<ul>
<li>累积备份</li>
<li>差异备份</li>
</ul>
</li>
<li>关键数据备份</li>
</ul>
</li>
<li>备份策略
<ul>
<li>每周备份的script
<ul>
<li>cp、tar、crontab</li>
</ul>
</li>
<li>每日备份的script
<ul>
<li>cp、tar、crontab</li>
</ul>
</li>
<li>远程备援的script
<ul>
<li>rsync、ssh</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="第二十一章-软件安装原始码与tarball">
  第二十一章 软件安装：原始码与Tarball
  <a class="anchor" href="#%e7%ac%ac%e4%ba%8c%e5%8d%81%e4%b8%80%e7%ab%a0-%e8%bd%af%e4%bb%b6%e5%ae%89%e8%a3%85%e5%8e%9f%e5%a7%8b%e7%a0%81%e4%b8%8etarball">#</a>
</h1>
<ul>
<li>
<p>开放源码的软件安装</p>
<ul>
<li>
<p>开放源码、编译程序、可执行文件</p>
<ul>
<li>什么是可执行文件：二进制文件</li>
<li>什么是开放源码：程序代码，纯文档</li>
<li>什么是编译程序：将程序代码转译成机器看得懂的语言</li>
<li>程序代码（纯文档）通过编译程序，利用已存在的函数库，编译成可执行文件</li>
<li><img src="/../img/image-20230221212320963.png" alt="image-20230221212320963" /></li>
</ul>
</li>
<li>
<p>函式库</p>
<ul>
<li>什么是函式库：被呼叫来执行的一段功能函数</li>
</ul>
</li>
<li>
<p>make和configure</p>
<ul>
<li>make，makefile</li>
<li>通过侦测程序主动建立makefile，侦测程序的文件名一般为configure或config</li>
<li><img src="/../img/image-20230221212418704.png" alt="image-20230221212418704" /></li>
</ul>
</li>
<li>
<p>Tarball软件</p>
<ul>
<li>将源代码打包压缩，解压后里面一般有
<ul>
<li>源代码文件</li>
<li>侦测程序文件（configure或者config）</li>
<li>简易说明README、或者INSTALL</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>使用C语言进行编译的简单范例</p>
<ul>
<li>gcc hello.c 直接编译原始码</li>
<li>gcc -c 仅编译成目标文件object file，并不制作链接等功能
<ul>
<li>产生hello.o，不产生二进制执行档</li>
<li>原始码文件并非只有一个文件，无法直接进行编译</li>
</ul>
</li>
</ul>
</li>
<li>
<p>用make进行宏编译</p>
<ul>
<li>
<p>简化编译时需要下达的指令</p>
</li>
<li>
<p>仅针对修改了的文件编译，其他的object file不会被更动</p>
</li>
<li>
<p>基本语法</p>
<ul>
<li>
<p><img src="/../img/image-20230221212555607.png" alt="image-20230221212555607" /></p>
</li>
<li>
<p>#批注</p>
</li>
</ul>
</li>
<li>
<p>变量</p>
<ul>
<li>
<p><img src="/../img/image-20230221212636401.png" alt="image-20230221212636401" /></p>
</li>
<li>
<p><img src="/../img/image-20230221212950753.png" alt="image-20230221212950753" /></p>
</li>
<li>
<p>$@ 代表当前的目标 target</p>
</li>
<li>
<p>环境变量取用规则</p>
<ul>
<li>make指令列后面加上的环境变量优先</li>
<li>makefile里面的第二</li>
<li>shell原本的环境变量第三</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Tarball的管理与建议</p>
<ul>
<li>
<p><img src="/../img/image-20230221212739959.png" alt="image-20230221212739959" /></p>
</li>
<li>
<p>大部分安装流程需要的指令</p>
<ul>
<li>.configure</li>
<li>make clean</li>
<li>make</li>
<li>make install</li>
</ul>
</li>
<li>
<p>建议软件安装在/usr/local下，原始码tarball放在/usr/local/src下</p>
</li>
<li>
<p>利用diff，patch更新软件</p>
<ul>
<li>patch的功能是更新原始码文件，还是要将软件进行编译后，才能最终得到正确的软件</li>
<li>如果版本跨度较大没有对应的patch文件，需要依序更新</li>
</ul>
</li>
</ul>
</li>
<li>
<p>函式库管理</p>
<ul>
<li>动态与静态函式库
<ul>
<li>静态函式库 .a：编译的时候直接整合到执行程序当中，编译后的可执行文件可以独立执行
<ul>
<li>函式库升级后，整个执行档必须重新编译</li>
</ul>
</li>
<li>动态函数库 .so，没有整合到执行文件当中，程序里面只有一个指针pointer的位置，编译出来的程序不能独立执行
<ul>
<li>函式库文件必须要存在，所在的目录也不能改变</li>
<li>函式库更新后，无需重新编译，函式库的升级方便</li>
</ul>
</li>
</ul>
</li>
<li>将常用的动态函式库加载到内存中，增进读取速度：ldconfig</li>
<li>判断可执行binary文件里面含有哪些动态函式库：ldd</li>
</ul>
</li>
<li>
<p>检查软件的正确性</p>
<ul>
<li>检查文件的指纹码</li>
<li>可以为重要的文件建立指纹数据库（例如/etc/shadow），然后写脚本定期检查指纹表是不是变化了</li>
</ul>
</li>
</ul>
<h1 id="第二十二章-软件安装rpmsrpm与yum">
  第二十二章 软件安装RPM，SRPM与YUM
  <a class="anchor" href="#%e7%ac%ac%e4%ba%8c%e5%8d%81%e4%ba%8c%e7%ab%a0-%e8%bd%af%e4%bb%b6%e5%ae%89%e8%a3%85rpmsrpm%e4%b8%8eyum">#</a>
</h1>
<p><img src="/../img/image-20230221213050454.png" alt="image-20230221213050454" /></p>
<p><img src="/../img/image-20230221213117775.png" alt="image-20230221213117775" /></p>
<ul>
<li>RPM有软件属性相依的问题，所以出现了YUM机制</li>
<li>现在主要利用rpm来做查询</li>
</ul>
<p><img src="/../img/image-20230221213155747.png" alt="image-20230221213155747" /></p>
<p><img src="/../img/image-20230221213326856.png" alt="image-20230221213326856" /></p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第零章-计算机基础">第零章 计算机基础</a></li>
    <li><a href="#第一章-linux是什么">第一章 Linux是什么</a></li>
    <li><a href="#第二章-主机规划与磁盘分区">第二章 主机规划与磁盘分区</a></li>
    <li><a href="#第三章-安装一个linux系统s">第三章 安装一个Linux系统s</a></li>
    <li><a href="#第四章-首次登陆与线上求助">第四章 首次登陆与线上求助</a></li>
    <li><a href="#第五章-linux文件权限与目录配置">第五章 Linux文件权限与目录配置</a></li>
    <li><a href="#第六章-linux文件与目录管理">第六章 Linux文件与目录管理</a></li>
    <li><a href="#第七章-linux磁盘和文件系统">第七章 Linux磁盘和文件系统</a></li>
    <li><a href="#第八章-压缩打包与备份">第八章 压缩打包与备份</a></li>
    <li><a href="#第九章-vim">第九章 Vim</a></li>
    <li><a href="#第十章-bash">第十章 BASH</a></li>
    <li><a href="#第十一章-正规表示法与文件格式化处理">第十一章 正规表示法与文件格式化处理</a></li>
    <li><a href="#第十二章-shell-scripts">第十二章 Shell Scripts</a></li>
    <li><a href="#第十三章-账号管理与acl权限设定">第十三章 账号管理与ACL权限设定</a></li>
    <li><a href="#第十四章-磁盘配额quota与进阶文件系统管理">第十四章 磁盘配额(Quota)与进阶文件系统管理</a></li>
    <li><a href="#第十六章-进程管理与selinux初探">第十六章 进程管理与SELinux初探</a></li>
    <li><a href="#第十七章-系统服务daemons">第十七章 系统服务daemons</a></li>
    <li><a href="#第十八章-认识与分析登录档">第十八章 认识与分析登录档</a></li>
    <li><a href="#第十九章-开机流程模块管理与loader">第十九章 开机流程、模块管理与Loader</a></li>
    <li><a href="#第二十章-基础系统设定与备份策略">第二十章 基础系统设定与备份策略</a></li>
    <li><a href="#第二十一章-软件安装原始码与tarball">第二十一章 软件安装：原始码与Tarball</a></li>
    <li><a href="#第二十二章-软件安装rpmsrpm与yum">第二十二章 软件安装RPM，SRPM与YUM</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












